options{  JDK_VERSION = "1.7";  static = false;}PARSER_BEGIN(LQMLParser)package de.unibonn.iai.eis.luzzu.qml.parser;
import java.io.Reader ;import java.io.StringReader ;import java.util.ArrayList;import java.util.List;import java.util.Map ;import java.util.HashMap ;import de.unibonn.iai.eis.luzzu.qml.datatypes.Condition;import de.unibonn.iai.eis.luzzu.qml.datatypes.ConditionType;import de.unibonn.iai.eis.luzzu.qml.datatypes.Metric;import de.unibonn.iai.eis.luzzu.qml.datatypes.Action;import de.unibonn.iai.eis.luzzu.qml.datatypes.Rule;public class LQMLParser{  static Map<String,String> compilerMap;   }PARSER_END(LQMLParser)SKIP : { " " }SKIP : { "\r" | "\t" | "\n" | "//" }// Structural Keyword TokensTOKEN : { < DEF : "def" > }TOKEN : { < LABEL : "label" > }TOKEN : { < DESC : "description" > }TOKEN : { < MATCH : "match" > }TOKEN : { < ACTION : "action" > }TOKEN : { < METRICURI : "metric" > }// Header Keyword TokensTOKEN : { < AUTHOR : "author" > }TOKEN : { < PACKAGE : "package" > }// Condition Keyword TokensTOKEN : { < TYPEOF : "typeof" > }// Action Keyword TokensTOKEN : { < COUNT : "count" >}TOKEN : { < MAP : "map" >}// Operational TokensTOKEN : { < #CHAR : (["a"-"z" , "A"-"Z"])+ > }TOKEN : { < #NUMBER : (["0"-"9"])+ > }TOKEN : { < STRICT_STR : (< CHAR >)+ < STR > > }TOKEN : { < #STR : (< NUMBER > | < CHAR >)*  >  }TOKEN : { < QUOTED_STR: "\"" (~["\""])+ "\"" >}TOKEN : { < LBRACE : "{" >}TOKEN : { < RBRACE : "}" >}TOKEN : { < LPAREN : "(" >}TOKEN : { < RPAREN : ")" >}TOKEN : { < COLON : ":" >}TOKEN : { < SEMI_COLON : ";" >}TOKEN : { < PERIOD : "." >}TOKEN : { < QUOTES : "\"" >}TOKEN : { < BOOLEAN_OPERATOR : < EQ > | < NEQ> | < LT > | < GT > | < LTE > | < GTE >  > }TOKEN : { < #EQ : "==" >}TOKEN : { < #NEQ : "!=" >}TOKEN : { < #LT : "<" >}TOKEN : { < #GT : ">" >}TOKEN : { < #LTE : "<=" >}TOKEN : { < #GTE : ">=" >}TOKEN : { < LOGICAL_OPERATOR : "&" | "|" | "!"> }TOKEN : { < HEADER_INDICATOR : "%%" >}// LD Specific TokensTOKEN : { < SUBJECT_VAR : "?s" > }TOKEN : { < PREDICATE_VAR : "?p" > }TOKEN : { < OBJECT_VAR : "?o" > }TOKEN : { < IRIref: "<" (~[ ">","<", "\"", "{", "}", "^", "\\", "|", "`", "\u0000"-"\u0020"])* ">" > }// BNF DefinitionMap<String,String>  parse():{ compilerMap = new HashMap<String,String>();}{  extractHeader()  {compilerMap.put("[%%classname%%]",extractDefinitionName());}  {compilerMap.put("[%%metricuri%%]",extractMetricURI());}  {compilerMap.put("[%%label%%]",extractLabel());}  {compilerMap.put("[%%description%%]",extractDescription());}    {    Rule r = extractRule();  	Action a = extractAction();  	Metric metric = new Metric(r, a);  	{compilerMap.put("[%%computefunction%%]",metric.getComputeFunction());}  	{compilerMap.put("[%%imports%%]",metric.getImports());}  	{compilerMap.put("[%%variables%%]",metric.getVariables());}  	{compilerMap.put("[%%metricvaluefuntion%%]",metric.actionToJava());}  }  < PERIOD > <EOF> { return compilerMap;}}void extractHeader():{}{  {    compilerMap.put("[%%author%%]",extractAuthor());    compilerMap.put("[%%packagename%%]",extractPackage());  }}String extractAuthor():{  Token t;  String author = "";}{< HEADER_INDICATOR >< AUTHOR >< COLON >t = <QUOTED_STR>{ author = t.image.replace("\"","") ; }{ return author; }}String extractPackage():{  Token t;  String pkg = "";}{  	< HEADER_INDICATOR >	< PACKAGE >	< COLON >	t = <QUOTED_STR>	{ pkg = t.image.replace("\"","")  ; }	{ return pkg; }}String extractDefinitionName():{  Token t;}{	<DEF>	<LBRACE>	t = <STRICT_STR>	{String s = t.image.replace("\"","") ;}	< RBRACE >	< COLON >	{return s;}}String extractLabel():{  Token t;}{	<LABEL>	<LBRACE>	t = <QUOTED_STR>	{ String s = t.image.replace("\"","") ; }	<RBRACE>	<SEMI_COLON>	{return s;}}String extractDescription():{  Token t;}{	<DESC>	<LBRACE>	t = <QUOTED_STR>	{ String s = t.image; }	<RBRACE>	<SEMI_COLON>	{return s;}}Rule extractRule():{  Rule r = new Rule();  List<ArrayList<Condition>> conditionList = new ArrayList<ArrayList<Condition>>();}{  	<MATCH>	<LBRACE>	{ArrayList<Condition> condLst = new ArrayList<Condition>(); }	extractCondition(condLst)	{conditionList.add(condLst);}	<RBRACE>	<SEMI_COLON>	{r.setConditionList(conditionList);}	{return r;}}void extractCondition(ArrayList<Condition> condLst):{  Token t;}{  <LPAREN>  (    // Write all possible conditions (incl. tokens)    <LPAREN>    t = < TYPEOF >    {condLst.add(extractTypeOf());}      <RPAREN>    |    // This is the case when we have just a normal condition (var op val)    {condLst.add(extractNonDefinedCondition());}  )  (<LOGICAL_OPERATOR>  extractCondition(condLst))*  <RPAREN>}Condition extractTypeOf():{  Token t;  Condition c = new Condition();}{  	<LPAREN><SUBJECT_VAR><RPAREN>  	t = <BOOLEAN_OPERATOR>  	{c.setBooleanOperator(t.image); }   	t = < IRIref >	{			c.setConditionType(ConditionType.TYPEOF);		c.setRhs(t.image);		return c;	}}Condition extractNonDefinedCondition():{  Token t, t2, t3;  Condition c = new Condition();  c.setConditionType(ConditionType.NORMAL);}{   	( 	  t = < SUBJECT_VAR > 	  { c.setLhs("?s"); } 	  ( 	   	t2 = < BOOLEAN_OPERATOR > 		t3 = <IRIref> 	  ) | 	  t = < PREDICATE_VAR >	{ c.setLhs("?p"); } 	  ( 	    t2 = < BOOLEAN_OPERATOR > 		t3 = <IRIref> 	  ) | 	  t = < OBJECT_VAR > 	   	  { c.setLhs("?o"); } 	  ( 	   	t2 = < BOOLEAN_OPERATOR > 		( 			t3 = <IRIref> | 			t3 = <QUOTED_STR> 		) 	  ) 	) 	{ c.setBooleanOperator(t2.image); 	c.setRhs(t3.image);  	  return c;}}Action extractAction():{  Token t;  Action action;}{  < ACTION >  < LBRACE >  (	< MAP > {action = Action.MAP;} |	< COUNT > {action = Action.COUNT;}  )  < RBRACE >  { return action;}}String extractMetricURI():{	Token t;}{  <  METRICURI >  < LBRACE >  t = < IRIref >  {String s = t.image.replace("<","").replace(">","") ;}  < RBRACE >  <SEMI_COLON>  {return s;}  }