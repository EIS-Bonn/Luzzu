options{  JDK_VERSION = "1.7";  static = false;}PARSER_BEGIN(LQMLParser)package de.unibonn.iai.eis.luzzu.qml.parser;
import java.io.Reader ;import java.io.StringReader ;import java.util.ArrayList;import java.util.List;import java.util.Map ;import java.util.HashMap ;import de.unibonn.iai.eis.luzzu.qml.datatypes.Condition;import de.unibonn.iai.eis.luzzu.qml.datatypes.ConditionType;import de.unibonn.iai.eis.luzzu.qml.datatypes.Metric;import de.unibonn.iai.eis.luzzu.qml.datatypes.Action;import de.unibonn.iai.eis.luzzu.qml.datatypes.Rule;public class LQMLParser{  static Map<String,String> compilerMap = new HashMap<String,String>();  static Condition condition = new Condition();  static Rule rule = new Rule();  static Action action;  static Metric metric;  static List<ArrayList<Condition>> conditionList = new ArrayList<ArrayList<Condition>>();    public static void main(String args []) throws ParseException  {    String test = "def{testOne}:"+    	"\n\tlabel{\"test label\"};" +    	"\n\tdescription{\"test description\"};"+    	"\n\trule{(?p == <http://www.w3.org/2002/07/owl#depreceted>)};" +   		"\n\taction{count}";        Reader reader = new StringReader(test) ;    LQMLParser parser = new LQMLParser( reader ) ;    StringBuffer buffer = new StringBuffer() ;        String s = parser.Parse() ;    metric = new Metric(rule, action);    System.out.println(metric.toJavaDecleration());  }}PARSER_END(LQMLParser)SKIP : { " " }SKIP : { "\r" | "\t" | "\n" }// Structural Keyword TokensTOKEN : { < DEF : "def" > }TOKEN : { < LABEL : "label" > }TOKEN : { < DESC : "description" > }TOKEN : { < RULE : "rule" > }TOKEN : { < ACTION : "action" > }// Condition Keyword TokensTOKEN : { < TYPEOF : "typeof" > }// Action Keyword TokensTOKEN : { < COUNT : "count" >}TOKEN : { < MAP : "map" >}// Operational TokensTOKEN : { < #CHAR : (["a"-"z" , "A"-"Z"])+ > }TOKEN : { < #NUMBER : (["0"-"9"])+ > }TOKEN : { < STRICT_STR : (< CHAR >)+ < STR > > }TOKEN : { < #STR : (< NUMBER > | < CHAR >)*  >  }TOKEN : { < QUOTED_STR: "\"" (~["\""])+ "\"" >}TOKEN : { < LBRACE : "{" >}TOKEN : { < RBRACE : "}" >}TOKEN : { < LPAREN : "(" >}TOKEN : { < RPAREN : ")" >}TOKEN : { < COLON : ":" >}TOKEN : { < SEMI_COLON : ";" >}TOKEN : { < QUOTES : "\"" >}TOKEN : { < BOOLEAN_OPERATOR : < EQ > | < NEQ> | < LT > | < GT > | < LTE > | < GTE >  > }TOKEN : { < #EQ : "==" >}TOKEN : { < #NEQ : "!=" >}TOKEN : { < #LT : "<" >}TOKEN : { < #GT : ">" >}TOKEN : { < #LTE : "<=" >}TOKEN : { < #GTE : ">=" >}TOKEN : { < LOGICAL_OPERATOR : "&" | "|" | "!"> }// LD Specific TokensTOKEN : { < SUBJECT_VAR : "?s" > }TOKEN : { < PREDICATE_VAR : "?p" > }TOKEN : { < OBJECT_VAR : "?o" > }TOKEN : { < IRIref: "<" (~[ ">","<", "\"", "{", "}", "^", "\\", "|", "`", "\u0000"-"\u0020"])* ">" > }// BNF DefinitionString Parse():{}{ // {compilerMap.put("definition",extractDefinitionName());}  //{compilerMap.put("label",extractLabel());}  //{compilerMap.put("description",extractDescription());}  //{compilerMap.put("rule",extractRule());}  extractDefinitionName()  extractLabel()  extractDescription()  extractRule()  extractAction()  <EOF>  {return "" ;}}String extractDefinitionName():{  Token t;}{	<DEF>	<LBRACE>	t = <STRICT_STR>	{String s = t.image;}	< RBRACE >	< COLON >	{return s;}}String extractLabel():{  Token t;}{	<LABEL>	<LBRACE>	t = <QUOTED_STR>	{ String s = t.image; }	<RBRACE>	<SEMI_COLON>	{return s;}}String extractDescription():{  Token t;}{	<DESC>	<LBRACE>	t = <QUOTED_STR>	{ String s = t.image; }	<RBRACE>	<SEMI_COLON>	{return s;}}void extractRule():{  Token t;  String s;}{  	<RULE>	<LBRACE>	{ArrayList<Condition> condLst = new ArrayList<Condition>(); }	extractCondition(condLst)	{conditionList.add(condLst);}	<RBRACE>	<SEMI_COLON>	{rule.setConditionList(conditionList);}}void extractCondition(ArrayList<Condition> condLst):{  Token t;  String s = "";}{  <LPAREN>  (    // Write all possible conditions (incl. tokens)    <LPAREN>    t = < TYPEOF >    {condLst.add(extractTypeOf());}      <RPAREN>    |    // This is the case when we have just a normal condition (var op val)    {condLst.add(extractNonDefinedCondition());}  )  (<LOGICAL_OPERATOR>  extractCondition(condLst))*  <RPAREN>}Condition extractTypeOf():{  Token t;  Condition c = new Condition();}{  	<LPAREN><SUBJECT_VAR><RPAREN>  	t = <BOOLEAN_OPERATOR>  	{c.setBooleanOperator(t.image); }   	t = < IRIref >	{			c.setConditionType(ConditionType.TYPEOF);		c.setRhs(t.image);		return c;	}}Condition extractNonDefinedCondition():{  Token t, t2, t3;  Condition c = new Condition();  c.setConditionType(ConditionType.NORMAL);}{   	( 	  t = < SUBJECT_VAR > 	  { c.setLhs("?s"); } 	  ( 	   	t2 = < BOOLEAN_OPERATOR > 		t3 = <IRIref> 	  ) | 	  t = < PREDICATE_VAR >	{ c.setLhs("?p"); } 	  ( 	    t2 = < BOOLEAN_OPERATOR > 		t3 = <IRIref> 	  ) | 	  t = < OBJECT_VAR > 	   	  { c.setLhs("?o"); } 	  ( 	   	t2 = < BOOLEAN_OPERATOR > 		( 			t3 = <IRIref> | t3 = <QUOTED_STR> 		) 	  ) 	) 	{ c.setBooleanOperator(t2.image);  	  c.setRhs(t3.image); 	  return c;}}void extractAction():{  Token t;}{  < ACTION >  < LBRACE >  (	< MAP > {action = Action.MAP;} |	< COUNT > {action = Action.COUNT;}  )  < RBRACE >}